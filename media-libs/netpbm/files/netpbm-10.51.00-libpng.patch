A first stab at fixing netpbm for libpng-1.5.  It at least compiles with this
patch.

--  Stuart Longland (redhatter@gentoo.org)

--- netpbm-10.51.00/converter/other/pamrgbatopng.c.orig	2011-07-19 00:58:57.212999572 +1000
+++ netpbm-10.51.00/converter/other/pamrgbatopng.c	2011-07-19 00:59:05.573000371 +1000
@@ -101,10 +101,12 @@
     if (!infoP)
         pm_error("Could not allocate PNG info structure");
     else {
-        infoP->width      = pamP->width;
-        infoP->height     = pamP->height;
-        infoP->bit_depth  = 8;
-        infoP->color_type = PNG_COLOR_TYPE_RGB_ALPHA;
+    	png_set_IHDR(pngP, infoP,
+			pamP->width, pamP->height, 8,
+			PNG_COLOR_TYPE_RGB_ALPHA,
+			PNG_INTERLACE_NONE,
+			PNG_COMPRESSION_TYPE_DEFAULT,
+			PNG_FILTER_TYPE_DEFAULT);
         
         png_init_io(pngP, ofP);
 
--- netpbm-10.51.00/converter/other/pngtxt.c.orig	2011-07-18 23:35:56.686000302 +1000
+++ netpbm-10.51.00/converter/other/pngtxt.c	2011-07-18 23:47:37.493000403 +1000
@@ -240,12 +240,13 @@
 
 
 void 
-pnmpng_read_text (png_info * const info_ptr, 
+pnmpng_read_text (struct pngx* const pngxP, 
                   FILE *     const tfp, 
                   bool       const ztxt,
                   bool       const verbose) {
 
     const char * textline;
+    struct png_text_struct* text;
     unsigned int lineLength;
     unsigned int commentIdx;
     bool noCommentsYet;
@@ -257,8 +258,8 @@
 
     allocatedComments = 256;  /* initial value */
 
-    MALLOCARRAY(info_ptr->text, allocatedComments);
-    if (info_ptr->text == NULL) 
+    MALLOCARRAY(text, allocatedComments);
+    if (text == NULL) 
         pm_error("unable to allocate memory for comment array");
 
     commentIdx = 0;
@@ -273,7 +274,7 @@
             if (lineLength == 0) {
                 /* skip this empty line */
             } else {
-                handleArrayAllocation(&info_ptr->text, &allocatedComments,
+                handleArrayAllocation(&text, &allocatedComments,
                                       commentIdx);
                 if ((textline[0] != ' ') && (textline[0] != '\t')) {
                     /* Line doesn't start with white space, which
@@ -285,7 +286,7 @@
                         ++commentIdx;
                     noCommentsYet = FALSE;
 
-                    startComment(&info_ptr->text[commentIdx], 
+                    startComment(&text[commentIdx], 
                                  textline, lineLength, ztxt);
                 } else {
                     /* Line starts with whitespace, which means it is
@@ -295,7 +296,7 @@
                         pm_error("Invalid comment file format: "
                                  "first line is a continuation line! "
                                  "(It starts with whitespace)");
-                    continueComment(&info_ptr->text[commentIdx], 
+                    continueComment(&text[commentIdx], 
                                     textline, lineLength);
                 }
             }
@@ -303,12 +304,13 @@
         }
     } 
     if (noCommentsYet)
-        info_ptr->num_text = 0;
+        png_set_text(pngxP->png_ptr, pngxP->info_ptr, NULL, 0);
     else
-        info_ptr->num_text = commentIdx + 1;
-
+        png_set_text(pngxP->png_ptr, pngxP->info_ptr, text, commentIdx + 1);
+    /* TODO: does this leak memory if noCommentsYet is true? */
     if (verbose)
-        pm_message("%d comments placed in text chunk", info_ptr->num_text);
+        pm_message("%d comments placed in text chunk",
+	    noCommentsYet ? 0 : commentIdx+1);
 }
 
 
--- netpbm-10.51.00/converter/other/pnmtopng.c.orig	2011-07-18 22:25:20.358000284 +1000
+++ netpbm-10.51.00/converter/other/pnmtopng.c	2011-07-18 23:35:42.038000349 +1000
@@ -58,7 +58,8 @@
 #include <assert.h>
 #include <string.h> /* strcat() */
 #include <limits.h>
-#include <png.h>    /* includes zlib.h and setjmp.h */
+#include <png.h>    /* includes setjmp.h */
+#include <zlib.h>
 
 #include "pm_c_util.h"
 #include "pnm.h"
@@ -2180,7 +2181,7 @@
             gray *               const alpha_mask,
             colorhash_table      const cht,
             coloralphahash_table const caht,
-            png_info *           const info_ptr,
+            struct pngx *        const pngxP,
             xelval               const png_maxval,
             unsigned int         const depth) {
             
@@ -2192,20 +2193,22 @@
         xel p_png;
         xel const p = xelrow[col];
         PPM_DEPTH(p_png, p, maxval, png_maxval);
-        if (info_ptr->color_type == PNG_COLOR_TYPE_GRAY ||
-            info_ptr->color_type == PNG_COLOR_TYPE_GRAY_ALPHA) {
+	png_byte color_type = png_get_color_type(pngxP->png_ptr,
+			pngxP->info_ptr);
+        if (color_type == PNG_COLOR_TYPE_GRAY ||
+            color_type == PNG_COLOR_TYPE_GRAY_ALPHA) {
             if (depth == 16)
                 *pp++ = PNM_GET1(p_png) >> 8;
             *pp++ = PNM_GET1(p_png) & 0xff;
-        } else if (info_ptr->color_type == PNG_COLOR_TYPE_PALETTE) {
+        } else if (color_type == PNG_COLOR_TYPE_PALETTE) {
             unsigned int paletteIndex;
             if (alpha)
                 paletteIndex = lookupColorAlpha(caht, &p, &alpha_mask[col]);
             else
                 paletteIndex = ppm_lookupcolor(cht, &p);
             *pp++ = paletteIndex;
-        } else if (info_ptr->color_type == PNG_COLOR_TYPE_RGB ||
-                   info_ptr->color_type == PNG_COLOR_TYPE_RGB_ALPHA) {
+        } else if (color_type == PNG_COLOR_TYPE_RGB ||
+                   color_type == PNG_COLOR_TYPE_RGB_ALPHA) {
             if (depth == 16)
                 *pp++ = PPM_GETR(p_png) >> 8;
             *pp++ = PPM_GETR(p_png) & 0xff;
@@ -2218,7 +2221,7 @@
         } else
             pm_error("INTERNAL ERROR: undefined color_type");
                 
-        if (info_ptr->color_type & PNG_COLOR_MASK_ALPHA) {
+        if (color_type & PNG_COLOR_MASK_ALPHA) {
             int const png_alphaval = (int)
                 alpha_mask[col] * (float) png_maxval / maxval + 0.5;
             if (depth == 16)
@@ -2274,7 +2277,7 @@
             
             makePngLine(line, xelrow, cols, maxval,
                         alpha, alpha ? alpha_mask[row] : NULL,
-                        cht, caht, pngxP->info_ptr, png_maxval, depth);
+                        cht, caht, pngxP, png_maxval, depth);
 
             png_write_row(pngxP->png_ptr, line);
         }
@@ -2293,7 +2296,7 @@
             unsigned int const rows,
             xelval       const maxval,
             int          const format,
-            png_info *   const info_ptr,
+            struct pngx* const pngxP,
             bool         const verbose) {
 
     if (histRequested) {
@@ -2324,8 +2327,7 @@
                         histogram[i] = chv[chvIndex].value;
                 }
             
-                info_ptr->valid |= PNG_INFO_hIST;
-                info_ptr->hist = histogram;
+                png_set_hIST(pngxP->png_ptr, pngxP->info_ptr, histogram);
                 if (verbose)
                     pm_message("histogram created in PNG stream");
             }
@@ -2336,41 +2338,44 @@
 
 
 
-static void
+static png_byte
 setColorType(struct pngx * const pngxP,
              bool          const colorMapped,
              int           const pnmType,
              bool          const alpha) {
 
+    png_byte color_type = 0;
+
     if (colorMapped)
-        pngxP->info_ptr->color_type = PNG_COLOR_TYPE_PALETTE;
+        color_type = PNG_COLOR_TYPE_PALETTE;
     else if (pnmType == PPM_TYPE)
-        pngxP->info_ptr->color_type = PNG_COLOR_TYPE_RGB;
+        color_type = PNG_COLOR_TYPE_RGB;
     else
-        pngxP->info_ptr->color_type = PNG_COLOR_TYPE_GRAY;
+        color_type = PNG_COLOR_TYPE_GRAY;
 
-    if (alpha && pngxP->info_ptr->color_type != PNG_COLOR_TYPE_PALETTE)
-        pngxP->info_ptr->color_type |= PNG_COLOR_MASK_ALPHA;
+    if (alpha && color_type != PNG_COLOR_TYPE_PALETTE)
+        color_type |= PNG_COLOR_MASK_ALPHA;
+    return color_type;
 }
 
 
 
 static void
 doGamaChunk(struct cmdlineInfo const cmdline,
-            png_info *         const info_ptr) {
+            struct pngx *      const pngxP) {
             
     if (cmdline.gammaSpec) {
         /* gAMA chunk */
-        info_ptr->valid |= PNG_INFO_gAMA;
-        info_ptr->gamma = cmdline.gamma;
+        png_set_gAMA(pngxP->png_ptr, pngxP->info_ptr, cmdline.gamma);
     }
 }
 
 
-
+/* TODO: needs porting */
+#if 0
 static void
 doChrmChunk(struct cmdlineInfo const cmdline,
-            png_info *         const info_ptr) {
+            struct pngx *      const pngxP) {
 
     if (cmdline.rgbSpec) {
         /* cHRM chunk */
@@ -2386,20 +2391,19 @@
         info_ptr->y_blue  = cmdline.rgb.by;
     }
 }
+#endif
 
 
 
 static void
 doPhysChunk(struct cmdlineInfo const cmdline,
-            png_info *         const info_ptr) {
+            struct pngx *      const pngxP) {
 
     if (cmdline.sizeSpec) {
         /* pHYS chunk */
-        info_ptr->valid |= PNG_INFO_pHYs;
-
-        info_ptr->x_pixels_per_unit = cmdline.size.x;
-        info_ptr->y_pixels_per_unit = cmdline.size.y;
-        info_ptr->phys_unit_type    = cmdline.size.unit;
+        png_set_pHYs(pngxP->png_ptr, pngxP->info_ptr,
+                        cmdline.size.x, cmdline.size.y,
+                        cmdline.size.unit);
     }
 }
 
@@ -2408,13 +2412,14 @@
 
 static void
 doTimeChunk(struct cmdlineInfo const cmdline,
-            png_info *         const info_ptr) {
+            struct pngx *      const pngxP) {
 
     if (cmdline.modtimeSpec) {
         /* tIME chunk */
-        info_ptr->valid |= PNG_INFO_tIME;
+        png_timep ptime;
 
-        png_convert_from_time_t(&info_ptr->mod_time, cmdline.modtime);
+        png_convert_from_time_t(ptime, cmdline.modtime);
+        png_set_tIME(pngxP->png_ptr, pngxP->info_ptr, ptime);
     }
 }
 
@@ -2450,8 +2455,8 @@
             pixel         const transColor,
             xelval        const maxval,
             xelval        const pngMaxval) {
-
-    switch (pngxP->info_ptr->color_type) {
+    png_byte color_type = png_get_color_type(pngxP->png_ptr, pngxP->info_ptr);
+    switch (color_type) {
     case PNG_COLOR_TYPE_PALETTE:
         if (transPaletteSize > 0) {
             png_set_tRNS(pngxP->png_ptr, pngxP->info_ptr,
@@ -2483,7 +2488,7 @@
 
 static void
 doBkgdChunk(bool         const bkgdRequested,
-            png_info *   const info_ptr,
+            struct pngx* const pngxP,
             unsigned int const backgroundIndex,
             pixel        const backColor,
             xelval       const maxval,
@@ -2491,33 +2496,28 @@
             bool         const verbose) {
     
     if (bkgdRequested) {
-        info_ptr->valid |= PNG_INFO_bKGD;
-        if (info_ptr->color_type == PNG_COLOR_TYPE_PALETTE) {
-            info_ptr->background.index = backgroundIndex;
-        } else {
-            info_ptr->background = 
-                xelToPngColor_16(backColor, maxval, pngMaxval);
-            if (verbose)
-                pm_message("Writing bKGD chunk with background color "
-                           " {gray, red, green, blue} = {%d, %d, %d, %d}",
-                           info_ptr->background.gray, 
-                           info_ptr->background.red, 
-                           info_ptr->background.green, 
-                           info_ptr->background.blue ); 
-        }
+        png_color_16 bg = xelToPngColor_16(backColor, maxval, pngMaxval);
+        png_set_bKGD(pngxP->png_ptr, pngxP->info_ptr, &bg);
+        if (verbose)
+            pm_message("Writing bKGD chunk with background color "
+                       " {gray, red, green, blue} = {%d, %d, %d, %d}",
+                       bg.gray, 
+                       bg.red, 
+                       bg.green, 
+                       bg.blue ); 
     }
 }
 
 
 
 static void
-doSbitChunk(png_info * const pngInfoP,
+doSbitChunk(struct pngx* const pngxP,
             xelval     const pngMaxval,
             xelval     const maxval,
             bool       const alpha,
             xelval     const alphaMaxval) {
-
-    if (pngInfoP->color_type != PNG_COLOR_TYPE_PALETTE &&
+    png_byte color_type = png_get_color_type(pngxP->png_ptr, pngxP->info_ptr);
+    if (color_type != PNG_COLOR_TYPE_PALETTE &&
         (pngMaxval > maxval || (alpha && pngMaxval > alphaMaxval))) {
 
         /* We're writing in a bit depth that doesn't match the maxval
@@ -2535,28 +2535,28 @@
            PNG doesn't allow it, we don't attempt to create such an
            sBIT chunk.
         */
-
-        pngInfoP->valid |= PNG_INFO_sBIT;
+        png_color_8 sig_bit;
 
         {
             int const sbitval = pm_maxvaltobits(MIN(maxval, pngMaxval));
 
-            if (pngInfoP->color_type & PNG_COLOR_MASK_COLOR) {
-                pngInfoP->sig_bit.red   = sbitval;
-                pngInfoP->sig_bit.green = sbitval;
-                pngInfoP->sig_bit.blue  = sbitval;
+            if (color_type & PNG_COLOR_MASK_COLOR) {
+                sig_bit.red   = sbitval;
+                sig_bit.green = sbitval;
+                sig_bit.blue  = sbitval;
             } else
-                pngInfoP->sig_bit.gray = sbitval;
+                sig_bit.gray = sbitval;
             
             if (verbose)
                 pm_message("Writing sBIT chunk with bits = %d", sbitval);
         }
-        if (pngInfoP->color_type & PNG_COLOR_MASK_ALPHA) {
-            pngInfoP->sig_bit.alpha =
+        if (color_type & PNG_COLOR_MASK_ALPHA) {
+            sig_bit.alpha =
                 pm_maxvaltobits(MIN(alphaMaxval, pngMaxval));
             if (verbose)
-                pm_message("  alpha bits = %d", pngInfoP->sig_bit.alpha);
+                pm_message("  alpha bits = %d", sig_bit.alpha);
         }
+        png_set_sBIT(pngxP->png_ptr, pngxP->info_ptr, &sig_bit);
     }
 }
 
@@ -2755,50 +2755,48 @@
     pm_error ("setjmp returns error condition (2)");
   }
 
-  pngxP->info_ptr->width = cols;
-  pngxP->info_ptr->height = rows;
-  pngxP->info_ptr->bit_depth = depth;
-
-  setColorType(pngxP, colorMapped, pnm_type, alpha);
-
-  pngxP->info_ptr->interlace_type = cmdline.interlace;
-
-  doGamaChunk(cmdline, pngxP->info_ptr);
-
-  doChrmChunk(cmdline, pngxP->info_ptr);
-
-  doPhysChunk(cmdline, pngxP->info_ptr);
+  png_byte color_type = setColorType(pngxP, colorMapped, pnm_type, alpha);
+  png_set_IHDR(pngxP->png_ptr, pngxP->info_ptr,
+                cols, rows, depth, color_type,
+                cmdline.interlace,
+                PNG_COMPRESSION_TYPE_DEFAULT,
+                PNG_FILTER_TYPE_DEFAULT);
+
+  doGamaChunk(cmdline, pngxP);
+  /* TODO: port doChrmChunk */
+#if 0
+  doChrmChunk(cmdline, pngxP);
+#endif
+  doPhysChunk(cmdline, pngxP);
 
-  if (pngxP->info_ptr->color_type == PNG_COLOR_TYPE_PALETTE) {
+  if (color_type == PNG_COLOR_TYPE_PALETTE) {
 
     /* creating PNG palette (Not counting the transparency palette) */
 
     createPngPalette(palette_pnm, palette_size, maxval,
                      trans_pnm, trans_size, alpha_maxval, 
                      palette, trans);
-    pngxP->info_ptr->valid |= PNG_INFO_PLTE;
-    pngxP->info_ptr->palette = palette;
-    pngxP->info_ptr->num_palette = palette_size;
+    png_set_PLTE(pngxP->png_ptr, pngxP->info_ptr, palette, palette_size);
 
     doHistChunk(cmdline.hist, palette_pnm, ifP, rasterPos,
                 cols, rows, maxval, format,
-                pngxP->info_ptr, cmdline.verbose);
+                pngxP, cmdline.verbose);
   }
 
   doTrnsChunk(pngxP, trans, trans_size,
               transparent, transcolor, maxval, png_maxval);
 
-  doBkgdChunk(!!cmdline.background, pngxP->info_ptr,
+  doBkgdChunk(!!cmdline.background, pngxP,
               background_index, backcolor,
               maxval, png_maxval, cmdline.verbose);
 
-  doSbitChunk(pngxP->info_ptr, png_maxval, maxval, alpha, alpha_maxval);
+  doSbitChunk(pngxP, png_maxval, maxval, alpha, alpha_maxval);
 
   /* tEXT and zTXT chunks */
   if (cmdline.text || cmdline.ztxt)
       pnmpng_read_text(pngxP->info_ptr, tfP, !!cmdline.ztxt, cmdline.verbose);
 
-  doTimeChunk(cmdline, pngxP->info_ptr);
+  doTimeChunk(cmdline, pngxP);
 
   if (cmdline.filterSet != 0)
       png_set_filter(pngxP->png_ptr, 0, cmdline.filterSet);
@@ -2809,7 +2807,8 @@
 
   /* write the png-info struct */
   png_write_info(pngxP->png_ptr, pngxP->info_ptr);
-
+#if 0
+  /* should no longer be necessary */
   if (cmdline.text || cmdline.ztxt)
       /* prevent from being written twice with png_write_end */
       pngxP->info_ptr->num_text = 0;
@@ -2817,7 +2816,7 @@
   if (cmdline.modtime)
       /* prevent from being written twice with png_write_end */
       pngxP->info_ptr->valid &= ~PNG_INFO_tIME;
-
+#endif
   /* let libpng take care of, e.g., bit-depth conversions */
   png_set_packing(pngxP->png_ptr);
 
--- netpbm-10.51.00/converter/other/pngtopam.c.orig	2011-07-19 10:36:55.824000869 +1000
+++ netpbm-10.51.00/converter/other/pngtopam.c	2011-07-19 11:31:59.253000640 +1000
@@ -171,24 +171,24 @@
 
 static unsigned int
 computePngLineSize(struct pngx * const pngxP) {
-
     unsigned int const bytesPerSample =
-        pngxP->info_ptr->bit_depth == 16 ? 2 : 1;
+        png_get_bit_depth(pngxP->png_ptr, pngxP->info_ptr) == 16 ? 2 : 1;
 
     unsigned int samplesPerPixel;
+    png_byte color_type = png_get_color_type(pngxP->png_ptr, pngxP->info_ptr);
+    unsigned int width = png_get_image_width(pngxP->png_ptr, pngxP->info_ptr);
 
-    switch (pngxP->info_ptr->color_type) {
+    switch (color_type) {
     case PNG_COLOR_TYPE_GRAY_ALPHA: samplesPerPixel = 2; break;
     case PNG_COLOR_TYPE_RGB:        samplesPerPixel = 3; break;
     case PNG_COLOR_TYPE_RGB_ALPHA:  samplesPerPixel = 4; break;
     default:                        samplesPerPixel = 1;
     }
 
-    if (UINT_MAX / bytesPerSample / samplesPerPixel < pngxP->info_ptr->width)
-        pm_error("Width %u of PNG is uncomputably large",
-                 (unsigned int)pngxP->info_ptr->width);
+    if (UINT_MAX / bytesPerSample / samplesPerPixel < width)
+        pm_error("Width %u of PNG is uncomputably large", width);
        
-    return pngxP->info_ptr->width * bytesPerSample * samplesPerPixel;
+    return width * bytesPerSample * samplesPerPixel;
 }
 
 
@@ -201,14 +201,14 @@
 
     png_byte ** pngImage;
     unsigned int row;
+    unsigned int height = png_get_image_height(pngxP->png_ptr, pngxP->info_ptr);
 
-    MALLOCARRAY(pngImage, pngxP->info_ptr->height);
+    MALLOCARRAY(pngImage, height);
 
     if (pngImage == NULL)
-        pm_error("couldn't allocate space for %u PNG raster rows",
-                 (unsigned int)pngxP->info_ptr->height);
+        pm_error("couldn't allocate space for %u PNG raster rows", height);
 
-    for (row = 0; row < pngxP->info_ptr->height; ++row) {
+    for (row = 0; row < height; ++row) {
         MALLOCARRAY(pngImage[row], lineSize);
         if (pngImage[row] == NULL)
             pm_error("couldn't allocate space for %uth row of PNG raster",
@@ -225,7 +225,7 @@
 
     unsigned int row;
 
-    for (row = 0; row < pngxP->info_ptr->height; ++row)
+    for (row = 0; row < png_get_image_height(pngxP->png_ptr, pngxP->info_ptr); ++row)
         free(pngRaster[row]);
 
     free(pngRaster);
@@ -252,7 +252,7 @@
 
     allocPngRaster(pngxP, &pngRaster);
 
-    if (pngxP->info_ptr->bit_depth < 8)
+    if (png_get_bit_depth(pngxP->png_ptr, pngxP->info_ptr) < 8)
         png_set_packing(pngxP->png_ptr);
 
     png_read_image(pngxP->png_ptr, pngRaster);
@@ -382,32 +382,33 @@
 saveText(struct pngx * const pngxP,
          FILE *        const tfP) {
 
-    png_info * const info_ptr = pngxP->info_ptr;
-
     unsigned int i;
+    png_textp text;
+    int num_text;
+    png_get_text(pngxP->png_ptr, pngxP->info_ptr, &text, &num_text);
 
-    for (i = 0 ; i < info_ptr->num_text; ++i) {
+    for (i = 0 ; i < num_text; ++i) {
         unsigned int j;
         j = 0;
 
-        while (info_ptr->text[i].key[j] != '\0' &&
-               info_ptr->text[i].key[j] != ' ')
+        while (text[i].key[j] != '\0' &&
+               text[i].key[j] != ' ')
             ++j;    
 
-        if (info_ptr->text[i].key[j] != ' ') {
-            fprintf(tfP, "%s", info_ptr->text[i].key);
-            for (j = strlen (info_ptr->text[i].key); j < 15; ++j)
+        if (text[i].key[j] != ' ') {
+            fprintf(tfP, "%s", text[i].key);
+            for (j = strlen (text[i].key); j < 15; ++j)
                 putc(' ', tfP);
         } else {
-            fprintf(tfP, "\"%s\"", info_ptr->text[i].key);
-            for (j = strlen (info_ptr->text[i].key); j < 13; ++j)
+            fprintf(tfP, "\"%s\"", text[i].key);
+            for (j = strlen (text[i].key); j < 13; ++j)
                 putc(' ', tfP);
         }
         putc(' ', tfP); /* at least one space between key and text */
     
-        for (j = 0; j < info_ptr->text[i].text_length; ++j) {
-            putc(info_ptr->text[i].text[j], tfP);
-            if (info_ptr->text[i].text[j] == '\n') {
+        for (j = 0; j < text[i].text_length; ++j) {
+            putc(text[i].text[j], tfP);
+            if (text[i].text[j] == '\n') {
                 unsigned int k;
                 for (k = 0; k < 16; ++k)
                     putc(' ', tfP);
@@ -427,14 +428,17 @@
         "July", "August", "September", "October", "November", "December"
     };
 
-    if (pngxP->info_ptr->valid & PNG_INFO_tIME) {
+    if (png_get_valid(pngxP->png_ptr, pngxP->info_ptr, PNG_INFO_tIME)) {
+        png_timep mod_time;
+        png_get_tIME(pngxP->png_ptr, pngxP->info_ptr, &mod_time);
+
         pm_message("modification time: %02d %s %d %02d:%02d:%02d",
-                   pngxP->info_ptr->mod_time.day,
-                   month[pngxP->info_ptr->mod_time.month],
-                   pngxP->info_ptr->mod_time.year,
-                   pngxP->info_ptr->mod_time.hour,
-                   pngxP->info_ptr->mod_time.minute,
-                   pngxP->info_ptr->mod_time.second);
+                   mod_time->day,
+                   month[mod_time->month],
+                   mod_time->year,
+                   mod_time->hour,
+                   mod_time->minute,
+                   mod_time->second);
     }
 }
 
@@ -443,11 +447,25 @@
 static void
 dumpPngInfo(struct pngx * const pngxP) {
 
-    png_info * const info_ptr = pngxP->info_ptr;
     const char *type_string;
     const char *filter_string;
+    int color_type, filter_type, bit_depth;
+    int interlace_type, filter_method, compression_type;
+    png_color* palette = NULL;
+    int num_palette = 0;
+    png_color_16p bg;
+    double gamma;
+
+    unsigned int width = png_get_image_width(pngxP->png_ptr, pngxP->info_ptr);
+    unsigned int height = png_get_image_height(pngxP->png_ptr, pngxP->info_ptr);
+
+    png_get_PLTE(pngxP->png_ptr, pngxP->info_ptr, &palette, &num_palette);
+    png_get_IHDR(pngxP->png_ptr, pngxP->info_ptr, NULL, NULL, &bit_depth,
+            &color_type, &interlace_type, &compression_type, &filter_method);
+    png_get_bKGD(pngxP->png_ptr, pngxP->info_ptr, &bg);
+    png_get_gAMA(pngxP->png_ptr, pngxP->info_ptr, &gamma);
 
-    switch (info_ptr->color_type) {
+    switch (color_type) {
       case PNG_COLOR_TYPE_GRAY:
         type_string = "gray";
         break;
@@ -469,90 +487,95 @@
         break;
     }
 
-    switch (info_ptr->filter_type) {
+    switch (filter_type) {
     case PNG_FILTER_TYPE_BASE:
         asprintfN(&filter_string, "base filter");
         break;
     default:
         asprintfN(&filter_string, "unknown filter type %d", 
-                  info_ptr->filter_type);
+                  filter_type);
     }
 
-    pm_message("reading a %ldw x %ldh image, %d bit%s",
-               info_ptr->width, info_ptr->height,
-               info_ptr->bit_depth, info_ptr->bit_depth > 1 ? "s" : "");
+    pm_message("reading a %uw x %uh image, %d bit%s",
+               width, height,
+               bit_depth, bit_depth > 1 ? "s" : "");
     pm_message("%s, %s, %s",
                type_string,
-               info_ptr->interlace_type ? 
+               interlace_type ? 
                "Adam7 interlaced" : "not interlaced",
                filter_string);
     pm_message("background {index, gray, red, green, blue} = "
                "{%d, %d, %d, %d, %d}",
-               info_ptr->background.index,
-               info_ptr->background.gray,
-               info_ptr->background.red,
-               info_ptr->background.green,
-               info_ptr->background.blue);
+               bg->index,
+               bg->gray,
+               bg->red,
+               bg->green,
+               bg->blue);
 
     strfree(filter_string);
 
-    if (info_ptr->valid & PNG_INFO_tRNS)
+    if (png_get_valid(pngxP->png_ptr, pngxP->info_ptr, PNG_INFO_tRNS)) {
+        png_bytep trans_alpha;
+        png_color_16p trans_color;
+        int num_trans;
+        png_get_tRNS(pngxP->png_ptr, pngxP->info_ptr, &trans_alpha,
+                        &num_trans, &trans_color);
         pm_message("tRNS chunk (transparency): %u entries",
-                   info_ptr->num_trans);
-    else
+                   num_trans);
+    } else
         pm_message("tRNS chunk (transparency): not present");
 
-    if (info_ptr->valid & PNG_INFO_gAMA)
-        pm_message("gAMA chunk (image gamma): gamma = %4.2f", info_ptr->gamma);
+    if (png_get_valid(pngxP->png_ptr, pngxP->info_ptr, PNG_INFO_gAMA))
+        pm_message("gAMA chunk (image gamma): gamma = %4.2f", gamma);
     else
         pm_message("gAMA chunk (image gamma): not present");
 
-    if (info_ptr->valid & PNG_INFO_sBIT)
+    if (png_get_valid(pngxP->png_ptr, pngxP->info_ptr, PNG_INFO_sBIT))
         pm_message("sBIT chunk: present");
     else
         pm_message("sBIT chunk: not present");
 
-    if (info_ptr->valid & PNG_INFO_cHRM)
+    if (png_get_valid(pngxP->png_ptr, pngxP->info_ptr, PNG_INFO_cHRM))
         pm_message("cHRM chunk: present");
     else
         pm_message("cHRM chunk: not present");
 
-    if (info_ptr->valid & PNG_INFO_PLTE)
-        pm_message("PLTE chunk: %d entries", info_ptr->num_palette);
+    if (png_get_valid(pngxP->png_ptr, pngxP->info_ptr, PNG_INFO_PLTE))
+        pm_message("PLTE chunk: %d entries", num_palette);
     else
         pm_message("PLTE chunk: not present");
 
-    if (info_ptr->valid & PNG_INFO_bKGD)
+    if (png_get_valid(pngxP->png_ptr, pngxP->info_ptr, PNG_INFO_bKGD))
         pm_message("bKGD chunk: present");
     else
         pm_message("bKGD chunk: not present");
 
-    if (info_ptr->valid & PNG_INFO_PLTE)
+    if (png_get_valid(pngxP->png_ptr, pngxP->info_ptr, PNG_INFO_hIST))
         pm_message("hIST chunk: present");
     else
         pm_message("hIST chunk: not present");
 
-    if (info_ptr->valid & PNG_INFO_pHYs)
+    if (png_get_valid(pngxP->png_ptr, pngxP->info_ptr, PNG_INFO_pHYs))
         pm_message("pHYs chunk: present");
     else
         pm_message("pHYs chunk: not present");
 
-    if (info_ptr->valid & PNG_INFO_oFFs)
+    if (png_get_valid(pngxP->png_ptr, pngxP->info_ptr, PNG_INFO_oFFs))
         pm_message("oFFs chunk: present");
     else
         pm_message("oFFs chunk: not present");
 
-    if (info_ptr->valid & PNG_INFO_tIME)
+    if (png_get_valid(pngxP->png_ptr, pngxP->info_ptr, PNG_INFO_tIME))
         pm_message("tIME chunk: present");
     else
         pm_message("tIME chunk: not present");
 
-    if (info_ptr->valid & PNG_INFO_pCAL)
+    if (png_get_valid(pngxP->png_ptr, pngxP->info_ptr, PNG_INFO_pCAL))
         pm_message("pCAL chunk: present");
     else
         pm_message("pCAL chunk: not present");
 
-    if (info_ptr->valid & PNG_INFO_sRGB)
+    if (png_get_valid(pngxP->png_ptr, pngxP->info_ptr, PNG_INFO_sRGB))
         pm_message("sRGB chunk: present");
     else
         pm_message("sRGB chunk: not present");
@@ -606,7 +629,7 @@
            pixels, and just do it ourselves.
         */
     
-        switch (pngxP->info_ptr->color_type) {
+        switch (png_get_color_type(pngxP->png_ptr, pngxP->info_ptr)) {
         case PNG_COLOR_TYPE_GRAY:
             retval = color.r == gammaCorrect(transColorP->gray, totalgamma);
             break;
@@ -633,9 +656,11 @@
         *totalgammaP = -1.0;
     else {
         float imageGamma;
-        if (pngxP->info_ptr->valid & PNG_INFO_gAMA)
-            imageGamma = pngxP->info_ptr->gamma;
-        else {
+        if (png_get_valid(pngxP->png_ptr, pngxP->info_ptr, PNG_INFO_gAMA)) {
+            double gamma;
+            png_get_gAMA(pngxP->png_ptr, pngxP->info_ptr, &gamma);
+            imageGamma = gamma;
+        } else {
             if (verbose)
                 pm_message("PNG doesn't specify image gamma.  Assuming 1.0");
             imageGamma = 1.0;
@@ -652,8 +677,10 @@
             *totalgammaP = imageGamma * displaygamma;
             /* in case of gamma-corrections, sBIT's as in the
                PNG-file are not valid anymore 
-            */
+
+               -- TODO: Will need to find another way of doing this. --
             pngxP->info_ptr->valid &= ~PNG_INFO_sBIT;
+            */
             if (verbose)
                 pm_message("image gamma is %4.2f, "
                            "converted for display gamma of %4.2f",
@@ -669,7 +696,8 @@
 
     bool retval;
 
-    if (pngxP->info_ptr->color_type == PNG_COLOR_TYPE_PALETTE) {
+    if (png_get_color_type(pngxP->png_ptr, pngxP->info_ptr)
+                    == PNG_COLOR_TYPE_PALETTE) {
         if (pngx_chunkIsPresent(pngxP, PNG_INFO_tRNS)) {
             bool foundGray;
             unsigned int i;
@@ -703,21 +731,24 @@
                    png_byte *    const fgSbitP,
                    bool *        const notUniformP) {
 
-    png_info * const pngInfoP = pngxP->info_ptr;
+    png_color_8p sig_bit;
+    png_byte color_type = png_get_color_type(pngxP->png_ptr, pngxP->info_ptr);
+
+    png_get_sBIT(pngxP->png_ptr, pngxP->info_ptr, &sig_bit);
 
-    if (pngInfoP->color_type == PNG_COLOR_TYPE_RGB ||
-        pngInfoP->color_type == PNG_COLOR_TYPE_RGB_ALPHA ||
-        pngInfoP->color_type == PNG_COLOR_TYPE_PALETTE) {
-        if (pngInfoP->sig_bit.red == pngInfoP->sig_bit.blue &&
-            pngInfoP->sig_bit.red == pngInfoP->sig_bit.green) {
+    if (color_type == PNG_COLOR_TYPE_RGB ||
+        color_type == PNG_COLOR_TYPE_RGB_ALPHA ||
+        color_type == PNG_COLOR_TYPE_PALETTE) {
+        if (sig_bit->red == sig_bit->blue &&
+            sig_bit->red == sig_bit->green) {
             *notUniformP = false;
-            *fgSbitP     = pngInfoP->sig_bit.red;
+            *fgSbitP     = sig_bit->red;
         } else
             *notUniformP = true;
     } else {
         /* It has only a gray channel so it's obviously uniform */
         *notUniformP = false;
-        *fgSbitP     = pngInfoP->sig_bit.gray;
+        *fgSbitP     = sig_bit->gray;
     }
 }
 
@@ -728,6 +759,8 @@
                  enum alpha_handling const alphaHandling,
                  png_byte *          const componentSbitP,
                  bool *              const notUniformP) {
+    png_color_8p sig_bit;
+    png_get_sBIT(pngxP->png_ptr, pngxP->info_ptr, &sig_bit);
 
     switch (alphaHandling) {
 
@@ -736,7 +769,7 @@
            the alpha Sbit
         */
         *notUniformP = false;
-        *componentSbitP = pngxP->info_ptr->sig_bit.alpha;
+        *componentSbitP = sig_bit->alpha;
         break;
     case ALPHA_NONE:
     case ALPHA_MIX:
@@ -755,7 +788,7 @@
         if (fgNotUniform)
             *notUniformP = true;
         else {
-            if (fgSbit == pngxP->info_ptr->sig_bit.alpha) {
+            if (fgSbit == sig_bit->alpha) {
                 *notUniformP    = false;
                 *componentSbitP = fgSbit;
             } else
@@ -781,11 +814,15 @@
                  shift);
     else {
         unsigned int i;
-        
-        for (i = 0; i < pngxP->info_ptr->num_palette; ++i) {
-            pngxP->info_ptr->palette[i].red   >>= (8 - shift);
-            pngxP->info_ptr->palette[i].green >>= (8 - shift);
-            pngxP->info_ptr->palette[i].blue  >>= (8 - shift);
+        png_color* palette = NULL;
+        int num_palette = 0;
+
+        png_get_PLTE(pngxP->png_ptr, pngxP->info_ptr, &palette, &num_palette);
+
+        for (i = 0; i < num_palette; ++i) {
+            palette[i].red   >>= (8 - shift);
+            palette[i].green >>= (8 - shift);
+            palette[i].blue  >>= (8 - shift);
         }
     }
 }
@@ -817,6 +854,8 @@
         /* The number of high-order significant bits in each RGB component.
            Meaningless if they aren't all the same (i.e. 'notUniform')
         */
+    png_byte color_type = png_get_color_type(pngxP->png_ptr, pngxP->info_ptr);
+    png_byte bit_depth = png_get_bit_depth(pngxP->png_ptr, pngxP->info_ptr);
 
     getComponentSbit(pngxP, alphaHandling, &componentSigBit, &notUniform);
 
@@ -824,7 +863,7 @@
         pm_message("This program cannot handle "
                    "different bit depths for color channels");
         pm_message("writing file with %u bit resolution",
-                   pngxP->info_ptr->bit_depth);
+                   bit_depth);
         *succeededP = false;
         *errorLevelP = PNMTOPNG_WARNING_LEVEL;
     } else if (componentSigBit > 15) {
@@ -835,21 +874,25 @@
         *errorLevelP = PNMTOPNG_WARNING_LEVEL;
     } else {
         if (alphaHandling == ALPHA_MIX &&
-            (pngxP->info_ptr->color_type == PNG_COLOR_TYPE_RGB_ALPHA ||
-             pngxP->info_ptr->color_type == PNG_COLOR_TYPE_GRAY_ALPHA ||
+            (color_type == PNG_COLOR_TYPE_RGB_ALPHA ||
+             color_type == PNG_COLOR_TYPE_GRAY_ALPHA ||
              paletteHasPartialTransparency(pngxP)))
             *succeededP = false;
         else {
-            if (componentSigBit < pngxP->info_ptr->bit_depth) {
+            if (componentSigBit < bit_depth) {
                 pm_message("Image has fewer significant bits, "
                            "writing file with %u bits", componentSigBit);
                 *maxvalP = (1l << componentSigBit) - 1;
                 *succeededP = true;
 
-                if (pngxP->info_ptr->color_type == PNG_COLOR_TYPE_PALETTE)
+                if (color_type == PNG_COLOR_TYPE_PALETTE)
                     shiftPalette(pngxP, componentSigBit);
-                else
-                    png_set_shift(pngxP->png_ptr, &pngxP->info_ptr->sig_bit);
+                else {
+                    png_color_8p sig_bit;
+
+                    if (png_get_sBIT(pngxP->png_ptr, pngxP->info_ptr, &sig_bit))
+                            png_set_shift(pngxP->png_ptr, sig_bit);
+                }
             } else
                 *succeededP = false;
         }
@@ -872,21 +915,20 @@
 
   Also set up *pngxP for the corresponding significant bits.
 -----------------------------------------------------------------------------*/
-    png_info * const pngInfoP = pngxP->info_ptr;
-
     bool gotItFromSbit;
+    png_byte color_type = png_get_color_type(pngxP->png_ptr, pngxP->info_ptr);
     
-    if (pngInfoP->valid & PNG_INFO_sBIT)
+    if (png_get_valid(pngxP->png_ptr, pngxP->info_ptr, PNG_INFO_sBIT))
         computeMaxvalFromSbit(pngxP, alphaHandling,
                               maxvalP, &gotItFromSbit, errorLevelP);
     else
         gotItFromSbit = false;
 
     if (!gotItFromSbit) {
-        if (pngInfoP->color_type == PNG_COLOR_TYPE_PALETTE) {
+        if (color_type == PNG_COLOR_TYPE_PALETTE) {
             if (alphaHandling == ALPHA_ONLY) {
-                if (pngInfoP->color_type == PNG_COLOR_TYPE_GRAY ||
-                    pngInfoP->color_type == PNG_COLOR_TYPE_RGB)
+                if (color_type == PNG_COLOR_TYPE_GRAY ||
+                    color_type == PNG_COLOR_TYPE_RGB)
                     /* The alpha mask will be all opaque, so maxval 1
                        is plenty
                     */
@@ -903,7 +945,8 @@
                 /* Use same maxval as PNG palette for simplicity */
                 *maxvalP = 255;
         } else {
-            *maxvalP = (1l << pngInfoP->bit_depth) - 1;
+            *maxvalP = (1l << png_get_bit_depth(pngxP->png_ptr,
+                                    pngxP->info_ptr)) - 1;
         }
     }
 }
@@ -914,19 +957,24 @@
 imageHasColor(struct pngx * const pngxP) {
 
     bool retval;
+    png_byte color_type = png_get_color_type(pngxP->png_ptr, pngxP->info_ptr);
 
-    if (pngxP->info_ptr->color_type == PNG_COLOR_TYPE_GRAY ||
-        pngxP->info_ptr->color_type == PNG_COLOR_TYPE_GRAY_ALPHA)
+    if (color_type == PNG_COLOR_TYPE_GRAY ||
+        color_type == PNG_COLOR_TYPE_GRAY_ALPHA)
 
         retval = FALSE;
-    else if (pngxP->info_ptr->color_type == PNG_COLOR_TYPE_PALETTE) {
+    else if (color_type == PNG_COLOR_TYPE_PALETTE) {
         bool foundColor;
         unsigned int i;
-            
+        png_color* palette = NULL;
+        int num_palette = 0;
+
+        png_get_PLTE(pngxP->png_ptr, pngxP->info_ptr, &palette, &num_palette);
+
         for (i = 0, foundColor = FALSE;
-             i < pngxP->info_ptr->num_palette && !foundColor;
+             i < num_palette && !foundColor;
              ++i) {
-            if (isColor(pngxP->info_ptr->palette[i]))
+            if (isColor(palette[i]))
                 foundColor = TRUE;
         }
         retval = foundColor;
@@ -1002,19 +1050,25 @@
         bgColorP->g = PPM_GETG(backcolor);
         bgColorP->b = PPM_GETB(backcolor);
 
-    } else if (pngxP->info_ptr->valid & PNG_INFO_bKGD) {
+    } else if (png_get_valid(pngxP->png_ptr, pngxP->info_ptr, PNG_INFO_bKGD)) {
         /* didn't manage to get libpng to work (bugs?) concerning background
            processing, therefore we do our own.
         */
-        switch (pngxP->info_ptr->color_type) {
+        png_color_16p bg;
+        png_get_bKGD(pngxP->png_ptr, pngxP->info_ptr, &bg);
+
+        switch (png_get_color_type(pngxP->png_ptr, pngxP->info_ptr)) {
         case PNG_COLOR_TYPE_GRAY:
         case PNG_COLOR_TYPE_GRAY_ALPHA:
             bgColorP->r = bgColorP->g = bgColorP->b = 
-                gammaCorrect(pngxP->info_ptr->background.gray, totalgamma);
+                gammaCorrect(bg->gray, totalgamma);
             break;
         case PNG_COLOR_TYPE_PALETTE: {
-            png_color const rawBgcolor = 
-                pngxP->info_ptr->palette[pngxP->info_ptr->background.index];
+            png_color* palette = NULL;
+            int num_palette = 0;
+            png_get_PLTE(pngxP->png_ptr, pngxP->info_ptr, &palette, &num_palette);
+
+            png_color const rawBgcolor = palette[bg->index];
             bgColorP->r = gammaCorrect(rawBgcolor.red, totalgamma);
             bgColorP->g = gammaCorrect(rawBgcolor.green, totalgamma);
             bgColorP->b = gammaCorrect(rawBgcolor.blue, totalgamma);
@@ -1022,11 +1076,9 @@
         break;
         case PNG_COLOR_TYPE_RGB:
         case PNG_COLOR_TYPE_RGB_ALPHA: {
-            png_color_16 const rawBgcolor = pngxP->info_ptr->background;
-            
-            bgColorP->r = gammaCorrect(rawBgcolor.red,   totalgamma);
-            bgColorP->g = gammaCorrect(rawBgcolor.green, totalgamma);
-            bgColorP->b = gammaCorrect(rawBgcolor.blue,  totalgamma);
+            bgColorP->r = gammaCorrect(bg->red,   totalgamma);
+            bgColorP->g = gammaCorrect(bg->green, totalgamma);
+            bgColorP->b = gammaCorrect(bg->blue,  totalgamma);
         }
         break;
         }
@@ -1041,10 +1093,12 @@
 warnNonsquarePixels(struct pngx * const pngxP,
                     int *         const errorLevelP) {
 
-    if (pngxP->info_ptr->valid & PNG_INFO_pHYs) {
-        float const r =
-            (float)pngxP->info_ptr->x_pixels_per_unit /
-            pngxP->info_ptr->y_pixels_per_unit;
+    if (png_get_valid(pngxP->png_ptr, pngxP->info_ptr, PNG_INFO_pHYs)) {
+        png_uint_32 xppu, yppu;
+        int unit;
+        png_get_pHYs(pngxP->png_ptr, pngxP->info_ptr, &xppu, &yppu, &unit);
+
+        float const r = (float)xppu / yppu;
 
         if (r != 1.0) {
             pm_message ("warning - non-square pixels; "
@@ -1085,7 +1139,8 @@
 
 
 
-#define GET_PNG_VAL(p) getPngVal(&(p), pngxP->info_ptr->bit_depth)
+#define GET_PNG_VAL(p) getPngVal(&(p), \
+                png_get_bit_depth(pngxP->png_ptr, pngxP->info_ptr))
 
 
 
@@ -1100,10 +1155,16 @@
 
     const png_byte * pngPixelP;
     unsigned int col;
+    png_color* palette = NULL;
+    int num_palette = 0;
+    png_byte color_type = png_get_color_type(pngxP->png_ptr, pngxP->info_ptr);
+
+    if (color_type == PNG_COLOR_TYPE_PALETTE)
+        png_get_PLTE(pngxP->png_ptr, pngxP->info_ptr, &palette, &num_palette);
 
     pngPixelP = &pngRasterRow[0];  /* initial value */
-    for (col = 0; col < pngxP->info_ptr->width; ++col) {
-        switch (pngxP->info_ptr->color_type) {
+    for (col = 0; col < png_get_image_width(pngxP->png_ptr, pngxP->info_ptr); ++col) {
+        switch (color_type) {
         case PNG_COLOR_TYPE_GRAY: {
             pngcolor fgColor;
             fgColor.r = fgColor.g = fgColor.b = GET_PNG_VAL(pngPixelP);
@@ -1126,7 +1187,7 @@
 
         case PNG_COLOR_TYPE_PALETTE: {
             png_uint_16 const index        = GET_PNG_VAL(pngPixelP);
-            png_color   const paletteColor = pngxP->info_ptr->palette[index];
+            png_color   const paletteColor = palette[index];
 
             pngcolor fgColor;
 
@@ -1165,8 +1226,7 @@
         break;
 
         default:
-            pm_error("unknown PNG color type: %d",
-                     pngxP->info_ptr->color_type);
+            pm_error("unknown PNG color type: %d", color_type);
         }
     }
 }
@@ -1226,7 +1286,7 @@
 
     tuplerow = pnm_allocpamrow(pamP);
 
-    for (row = 0; row < pngxP->info_ptr->height; ++row) {
+    for (row = 0; row < png_get_image_height(pngxP->png_ptr, pngxP->info_ptr); ++row) {
         makeTupleRow(pamP, tuplerow, pngxP, pngRaster[row], bgColor,
                      alphaHandling, totalgamma);
 
@@ -1280,8 +1340,8 @@
     pam.len         = PAM_STRUCT_SIZE(maxval);
     pam.file        = stdout;
     pam.plainformat = 0;
-    pam.height      = pngxP->info_ptr->height;
-    pam.width       = pngxP->info_ptr->width;
+    pam.height      = png_get_image_height(pngxP->png_ptr, pngxP->info_ptr);
+    pam.width       = png_get_image_width(pngxP->png_ptr, pngxP->info_ptr);
     pam.maxval      = maxval;
 
     determineOutputType(pngxP, cmdline.alpha, bgColor, maxval,
--- netpbm-10.51.00/converter/other/pngtxt.h.orig	2011-07-19 10:43:56.166000759 +1000
+++ netpbm-10.51.00/converter/other/pngtxt.h	2011-07-19 10:43:31.389000482 +1000
@@ -3,9 +3,10 @@
 
 #include "pm_c_util.h"
 #include <png.h>
+#include "pngx.h"
 
 void 
-pnmpng_read_text (png_info * const info_ptr, 
+pnmpng_read_text (struct pngx* const pngxP, 
                   FILE *     const tfp, 
                   bool const ztxt,
                   bool const verbose);
